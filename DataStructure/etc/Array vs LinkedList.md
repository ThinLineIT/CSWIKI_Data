# Array vs Linked List


## You can answer
- Array 와 LinkedList 의 차이가 무엇인가요?

<!--Contents-->

---
## 뭐가 어떻게 다른거야?

우선, 연결리스트와 배열이 어떤 특성을 가지고 있는지 알아보자.

### Array
    배열은 정적(static)인 자료구조이다. 왜 정적인가 하면, 배열을 만들기 위해서는 미리 그 크기를 정해놔야하기 때문이다.

- 크기를 정해놓고 배열을 만들게 되면 딱 그 크기 만큼 연속된 메모리 주소를 할당받는다. 따라서, 한번 크기를 정해 놓으면 크기 수정이 불가하고 배열 크기 이상의 데이터를 저장할 수 없다는 단점이 있다.

- 하지만 연속된 메모리 주소를 할당받기 때문에 생기는 큰 장점이 있는데, 데이터가 순차적으로 저장되기 때문에 데이터가 인덱스를 가지게 되면서 __임의 접근(random access)__ 이 가능해진다. 


### LinkedList
    반면에, 연결리스트는 동적(dynamic)인 자료구조이다. 정적이 아닌 동적인 이유는 연결리스트는 크기를 미리 정할 필요가 없기 때문이다.

연결리스트는 배열처럼 미리 연속된 메모리 주소를 할당받는 것이 아니다. 그렇다면 어떻게 저장된 데이터를 탐색할 수 있을까?

- 연결리스트에는 노드가 존재하는데, 그 노드에는 저장된 데이터 값과 다음 데이터가 있는 메모리 주소(단일 연결리스트의 경우)를 가지고 있다. 따라서 데이터들이 배열처럼 연속적으로 메모리에 저장되어 있지 않고 서로 떨어져 있어도 선형구조로 데이터를 저장할 수 있다는 장점이 있다.

- 이 장점은 곧 크기의 제한이 걸리지 않는다는 점이 되고 이 때문에 데이터 추가, 삭제가 굉장히 자유로워진다.

- 하지만 연결리스트는 배열처럼 연속적으로 메모리 주소를 할당받지 않기 때문에 임의 접근이 불가능하다. 때문에 연결리스트가 데이터를 탐색하는 방식은 순차 접근(sequential access) 방식을 사용한다.

- 이 Linked List 는 Tree 구조의 근간이 되는 자료구조이며, Tree 에서 사용되었을 때 그 유용성이 드러난다.

![array](https://user-images.githubusercontent.com/70083982/115988046-cf172000-a5f2-11eb-898e-752e6c19126a.jpeg)

---

## 연결리스트와 배열의 시간복잡도 차이

    어떤 경우에서는 연결리스트를 쓰는 것이 유리하고, 또 어떤 경우에는 배열을 쓰는 것이 유리하다. 연결리스트와 배열이 가지는 시간복잡도를 크게 데이터 탐색, 데이터 추가, 데이터 삭제 3가지로 나누어서 설명하겠다.
    
    
###  데이터 탐색

- __배열__ : 임의 접근 방식을 사용하기 때문에 데이터를 탐색할 때 처음부터 찾을 필요가 없다. 인덱스 번호가 있기 때문에 인덱스를 통해서 매우 빠르게 탐색할 수 있다. 이 때 배열은 __O(1)__ 의 시간복잡도를 가진다.

- __연결리스트__ : 순차 접근 방식을 사용하기 때문에 어떤 한 데이터를 찾기 위해서는 처음부터 순차적으로 탐색해야 한다.
따라서 이 때 연결리스트는 __O(n)__ 의 시간복잡도를 가진다.


### 데이터 추가

-__배열__ : 배열의 경우에는 데이터들이 순차적으로 저장되어있다. 데이터가 추가될 경우 그 뒤에 있는 데이터들을 전부 한 칸씩 뒤로 미뤄야 한다. 여기서 시간복잡도가 __O(n)__ 이다. 만약에 배열에 공간이 남아 있고 데이터를 맨 뒤에 추가한다면 이 때는 __O(1)__ 이다.

    1. 추가하려는 데이터가 맨 뒤가 아니라면, 추가되는 데이터 위치 이후에 있는 모든 데이터들을 한 칸씩 미뤄야 하므로 O(n)의 시간복잡도를 가진다.
    
    2. 추가하려는 데이터의 위치가 맨 뒤이고 배열에 공간이 남아있다면, O(1)의 시간복잡도를 가진다.


-__연결리스트___ : 먼저 오해하지 말아야 할 것이, 데이터를 추가하는 행위 자체의 시간복잡도는 __O(1)__ 이다. 노드가 가지고 있는 메모리 주소 값만 갈아 끼워주면 되기 때문이다. 다만, 추가하려는 데이터의 위치가 맨 처음이 아니고 그 이후라면 순차적으로 탐색하면서 해당 위치까지 가야한다. 이 때 발생하는 시간복잡도가 __O(n)__ 이다. 따라서 크게 두가지로 나눠볼 수 있다.

    1. 추가하려는 데이터의 위치가 맨 앞이라면, ​O(1)의 시간복잡도를 가진다.
    
    2. 추가하려는 데이터의 위치가 맨 앞 그 이후라면, O(n)의 시간복잡도를 가진다.


    
### 데이터 삭제

-__배열__ : 삭제도 삽입과 마찬가지다. 배열은 순차적으로 저장되어있으므로 데이터들을 옮겨줘야 하는 상황이 발생한다!

1. 삭제하려는 데이터의 위치가 맨 뒤가 아니라면, __O(n)__ 의 시간복잡도를 가진다.
2. 삭제하려는 데이터의 위치가 맨 뒤이고 배열에 공간이 남아있다면, __O(1)__ 의 시간복잡도를 가진다.


-__연결리스트__ :

1. 삭제하려는 데이터의 위치가 맨 앞이라면, __O(1)__ 의 시간복잡도를 가진다.
2. 삭제하려는 데이터의 위치가 맨 앞 그 이후라면, __O(n)__ 의 시간복잡도를 가진다.

​

---

## 요약


- Array는 Random Access를 지원한다. 요소들을 인덱스를 통해 직접 접근할 수 있다. 따라서 특정 요소에 접근하는 시간복잡도는 O(1)이다. 
- 반면 Linkedlist는 Sequential Access를 지원한다. 어떤 요소를 접근할 때 순차적으로 검색하며 찾아야 한다. 따라서 특정 요소에 접근할 때 시간복잡도는 O(N)이다.


- 배열에서 요소들은 인접한 메모리 위치에 연이어 저장된다. 
- Linkedlist에서는 새로운 요소에 할당된 메모리 위치 주소가 linkedlist의 이전 요소에 저장된다.


- 배열에서 삽입과 삭제는 O(N)이 소요된다.
- Linkedlist에서 삽입과 삭제는 O(1)이 소요된다.


- 배열에서 메모리는 선언 시 컴파일 타임에 할당이 된다.(정적 메모리 할당) 
- Linkedlist에서는 새로운 요소가 추가될 때 런타임에 메모리를 할당한다.(동적 메모리 할당)


- 배열은 Stack 섹션에 메모리 할당이 이루어 진다. 
- Linkedlist는 Heap 섹션에 메모리 할당이 이루어진다.


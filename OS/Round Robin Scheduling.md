# Round Robin Scheduling(RR)
<!--Table of Contents-->
- 비선점형, 선점형 스케줄링
- Round Robin Scheduling
- Round Robin Scheduling의 예시

<!-- 어떤 질문을 대답할 수 있어야 하는지-->
## You can answer
- 비선점형, 선점형 스케줄링이란?
- Round Robin Scheduling의 알고리즘
- Round Robin Scheduling의 효율, 장단점
<!--Contents-->

---
## 비선점형, 선점형 스케줄링이란?

### 스케줄링(Scheduling)
- 일반적인 스케줄링이란 처리할 일들의 진행순서를 정하는 일이며 프로세스, 디스크 스케줄링이 있습니다.

1. 프로세스 스케줄링이란 CPU를 사용하려고 하는 프로세스들 사이의 우선 순위를 관리하는 일

2. 디스크 스케줄링은 디스크를 사용하려고 하는 프로세서들 사이의 우선 순위를 관리하는 일

스케줄링은 처리율과 CPU 이용률을 증가시키고, 오버헤드/응답시간/반환시간/대기시간을 최소화 시키기 위한 기법입니다. 즉, CPU가 쉬지않고 계속 열심히 일할 수 있도록 효율적인 계획을 잡아 주는 것이 스케줄링입니다.


### 비선점, 선점 스케줄링
- 비선점 스케줄링 은 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법입니다. 선점 방식보다 스케줄러 호출 빈도가 낮고 문맥 교환에 의한 오버헤드도 적습니다. 일괄처리 시스템에 적합하고, CPU 사용 시간이 긴 하나의 프로세스가 CPU 사용 시간이 짧은 여러 프로세스를 오랫동안 대기시킬 수 있으므로, 처리율이 떨어질 수 있다는 단점도 있습니다.  

- 선점 스케줄링 은 하나의 프로세스가 CPU를 할당 받아 실행하고 있을 때 우선 순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 기법입니다. 모든 프로세스에게 CPU 사용 시간을 동일하게 부여할 수 있으며, 빠른 응답시간을 요하는 대화식 시분할 시스템에 적합하며 긴급한 프로세서를 제어할 수 있습니다.  
---
## Round Robin Scheduling
Round Robin Scheduling은 시분할 시스템(Time Sharing System)을 위해 설계된 스케줄링 기법입니다. CPU에게 할당된 총 프로세스들의 작업 시간을 여러 개로 쪼개는데 이 하나의 시간을 시간 할당량(Time-Slice) 혹은 타임 퀀텀(Time Quantum)으로 정의하여  그 시간 만큼 자원을 할당하는 방식입니다. 그래서 그 시간안에 작업을 끝내지 못하면 다음 프로세스가 다시 그 시간만큼 자원을 할당받아 사용합니다. 작업을 끝내지 못하고 타임 퀀텀이 지난 프로세스는 우선 순위가 제일 뒤로 밀리게 되며 다시 자신의 차례를 기다리는 방식입니다. 타임 퀀텀 이후에 다른 프로세스가 자원을 할당 받는 과정을 Context Switch라 하는데 이는 RR의 성능에 영향을 줍니다. 타임 퀀텀의 길이에 따라 달라지는데 너무 길면 FIFO(선입선출)로 변하고 짧으면 Context Switching 비용이 증가합니다. 그러면 타임퀀텀의 길이를 어느정도로 해야 성능이 좋을까요? 보통 cpu burst의 80%를 추천합니다. 프로세스는 cpu burst와  I/O burst를 왔다 갔다 바꿔가며 프로그램을 실행합니다. cpu burst는 cpu 명령을 실행하는 것을 의미하고 I/O burst는 I/O를 요청 후 대기하는 시간을 의미합니다.

###장점과 단점
- 장점  
1. 모든 프로세스가 공정하게 스케줄링을 받을 수 있습니다.
2. 프로세스의 짧은 응답시간을 갖고 최악의 응답시간을 알 수 있습니다.
3. 평균 대기시간이 상대적으로 적습니다.
- 단점  
1. 성능은 규정 시간량의 길이에 따라 달라지므로 작업이 비슷한 길이가 좋은데, 너무 길면 FIFO로 변하고 짧으면 문맥 교환(Context Switching) 비용이 증가합니다.
2. 하드웨어적 타이머가 필요합니다.
3. 미완성 작업은 규정 시간량(시간 할당량)을 마친 후 프로세서를 기다리니까 평균 처리 시간이 높습니다.

---
## Round Robin Scheduling의 예시
아래 그림을 보면 타임 퀀텀이 20이고 처리해야 할 프로세스가 4개 있습니다. 표에서 각 프로세스의 Brust time을 확인 할 수 있습니다. 아래 Gantt Chart를 보면 순차적으로 프로세스가 처리되고 있는데 먼저 1번 프로세스가 20을 모두 소모하고 2번 프로세스가 넘겨받습니다. 하지만 2번 프로세스의 경우 Brust time가 17이라 20안에 모두 끝내고 바로 다음 3번 프로세스가 받습니다. 후에 2번 프로세스는 끝났기 때문에 할당 받지 않습니다. 각 프로세스 별로 남은 시간을 표현하면 아래와 같습니다.  
p1-> 53 - 33 - 13 - 0  
p2-> 17 - 0  
p3-> 68 - 48 - 28 - 8 - 0  
p4-> 24 - 4 - 0  
![image](https://user-images.githubusercontent.com/22022393/127035819-066f26f6-ad90-4b5a-87e0-ebcec2573418.png)

---
## Reference
- [Round-Robin(RR)이란? , CPU-Scheduling들](https://jwprogramming.tistory.com/17 [개발자를 꿈꾸는 프로그래머])
- [스케줄링(SCHEDULING) 알고리즘](https://reakwon.tistory.com/132)
- [운영체제 RR(라운드 로빈)순환할당스케줄,타임퀀텀](https://jhnyang.tistory.com/158)

# 세마포어(Semaphore)와 뮤텍스(Mutex)
<!--Table of Contents-->
- 임계영역(Critical Section)

- 뮤텍스(Mutex)

- 세마포어(Semaphore)

- 세마포어(Semaphore)와 뮤텍스(Mutex)


<!-- 어떤 질문을 대답할 수 있어야 하는지-->
## You can answer
- 임계영역과 경쟁조건이란?
- 뮤텍스(Mutex)란?
- 세마포어(Semaphore)란?
- 데드락(dead lock)이란?
- 세마포어(Semaphore)와 뮤텍스(Mutex)의 차이

<!--Contents-->

---
## 임계영역(Critical Section)  
임계 영역은 공유 데이터에 접근하는 코드로 공유 데이터에 동시 접근하게 되면 데이터의 무결성이 손상될 수 있는데 이러한 문제가 바로 임계 영역 문제입니다. 프로세스 2개가 동시에 공유 자원에 접근함으로써 기대했던 값과는 다른 결과가 나올 수 있는데 이러한 상황을 경쟁조건(race condition)이라 합니다.  

 경쟁 조건(race condition)은 임계영역의 부적절한 처리로 예상치 못한 결과를 발생시킬 수 있는 상황을 의미하며 경쟁 조건 문제를 해소하기 위해서는 반드시 한 순간에 하나의 프로세스만 임계영역을 실행할 수 있도록 보장해야 합니다.

### 임계 영역 문제의 해결 3가지 조건
임계 영역 문제의 해결책이 되려면 상호 배제(Mutual Exclusion), 진행(Progress), 한정 대기(Bounded Waiting) 3가지 조건을 만족해야 한다.

1. 어떤 프로세스가 임계영역에 존재하는 경우, 다른 프로세스는 임계영역을 실행하지 못하도록 하면 상호 배제(Mutual Exclusion) 조건을 만족한다고 할 수 있다.

2. 임계 영역 안에서 실행하고 있는 프로세스가 없는 경우, 임계 영역을 실행하고자 하는 프로세스는 반드시 임계 영역을 실행할 수 있어야 한다. 이를 만족하면 진행(Progress) 조건을 만족한다고 할 수 있다.

3. 임계 영역을 요청한 프로세스는 무한히 대기하면 안된다. 즉, 제한된 대기 시간을 가져야 한다. 이를 만족하면 한정 대기(Bounded Waiting) 조건을 만족한다고 할 수 있다.  

 3가지 조건을 모두 만족해야만 임계 영역 문제(critical section problem)을 해결할 수 있는 해결책(solution)이라고 할 수 있다.

### 동기화 달성의 방법
세마포어, 뮤텍스 둘다 모두 동기화를에 이용되는 도구입니다. 여기서 동기화란 "공간과 시간"을 제어하는 방식으로 이루어지며 "접근 제어가 필요한 공간"을 지정하고 지정한 "공간에 진입 할 수 있는 시간"을 제어하는 방식입니다.  
여기에서 "접근 제어가 필요한 공간"에는 보호 해야 할 공유 자원이 있으며 보호 해야할 공유 자원이 있는 공간을 임계 영역(Critical Section)이라고 합니다. 시간 제어는 해당 임계 영역에 동 시간에 정해진 쓰레드만 접근하도록 제한 하는 방식으로 이루어집니다.  


## 뮤텍스(Mutex)
뮤텍스는, 쓰레드 간 임계 영역의 동기화를 위한 기법입니다. 작동 원리를 일상 생활에 비유하자면, 당신이 화장실을 가려고 하는데 카운터에 키가 있으면 화장실에 사람이 없다는 뜻이고 당신은 그 열쇠를 이용해 화장실에 들어갈 수 있습니다. 당신이 화장실을 사용하고 있는데 다른 테이블에 있는 어떤 남자가 화장실에 가고 싶어졌습니다. 하지만 이 남자가 아무리 용무가 급하더라도 열쇠가 없기 때문에 화장실에 들어갈 수 없고 남자는 당신이 용무를 마친 후 나올 때까지 카운터에서 기다려야 합니다. 곧이어 옆 테이블에 있는 남자도 화장실에 가고 싶어졌고 이 남자 또한 화장실에 들어가기 위해서는 카운터에서 대기해야 합니다. 이제 당신이 화장실에서 나와 카운터에 키를 돌려놓는다면 이제 기다리던 사람들 중 맨 앞에있던 사람은 키를 받을 수 있고 이를 이용해 화장실에 갈 수 있습니다.  
화장실을 이용하는 사람은 프로세스 혹은 쓰레드이며 화장실은 공유자원, 화장실 키는 공유자원에 접근하기 위해 필요한 어떤 오브젝트이며 이것이 뮤텍스의 작동 원리입니다.  
즉 뮤텍스는 Key 에 해당하는 어떤 오브젝트가 있으며 이 오브젝트를 소유한 (쓰레드,프로세스) 만이 공유자원에 접근할 수 있습니다.  

![image](https://user-images.githubusercontent.com/22022393/128606383-fcdcbfc3-832c-4df5-8065-ce1f337aa61b.png)

### 구현
lock 과 unlock 의 개념이 등장합니다.  
임계 영역에 먼저 들어가는 쓰레드가 lock 을 걸면, 이 쓰레드가 unlock 을 할 때 까지, 다른 쓰레드들은 임계 영역에 들어가지 못하도록 하는 것입니다.  
즉, 임계 영역에 들어가는 쓰레드는 임계 영역 앞뒤에 lock 과 unlock 을 해야합니다.  
```Python
v = 1;
def lock():
    while v != 1
            # 2. 이미 다른 쓰레드에 의해 선점된 경우, v=0 이므로, 이 루프를 계속 돈다.
        if (v==1)
            # 4. 앞서 선점한 쓰레드가 락을 풀면 v=1 이므로, 루프를 탈출한다.
            break;
    # 1. 먼저 선점한 쓰레드가 v=0 으로 만들어, 락을 잠가버린다.
    v = 0;

def unlock():
    # 3. 할 일을 하고나온 쓰레드는 v=1 로 만들어, 락을 푼다.
    v = 1;

lock() # 들어갈 때 락을 잠그고
# critical section
unlock() # 나갈 때 락을 푼다.
```

## 세마포어(Semaphore)
뮤텍스와 마찬가지로, 동기화 기법 중 하나지만, 뮤텍스는 임계 영역에 들어가는 쓰레드가 하나라면, 세마포어는 복수 개가 가능합니다. 뮤텍스처럼 작동원리에 대하여 비유하자면,
세마포어는 화장실에 여러 개의 칸이 있고 화장실 입구에는 현재 화장실의 빈 칸 개수를 보여주는 전광판이 있습니다. 만약 당신이 화장실에 가고 싶다면 입구에서 빈 칸의 개수를 확인하고 빈 칸이 1개 이상이라면 빈칸의 개수를 하나 뺀 다음에 화장실로 입장해야 합니다. 그리고 나올 때 빈 칸의 개수를 하나 더해줍니다. 모든 칸에 사람이 들어갔을 경우 빈 칸의 개수는 0이 되며 이때 화장실에 들어가고자 하는 사람이 있다면 빈 칸의 개수가 1로 바뀔 때까지 기다려야 합니다. 사람들은 나오면서 빈 칸의 개수를 1씩 더하고 기다리던 사람은 이 숫자에서 다시 1을 뺀 다음 화장실를 이용합니다. 이처럼 세마포어는 공통으로 관리하는 하나의 값을 이용해 상호배제를 충족시킵니다.  

세마포어도 아까와 똑같이 화장실이 공유자원이며 사람들이 쓰레드, 프로세스이고 화장실 빈칸의 개수는 현재 공유자원에 접근할 수 있는 쓰레드,프로세스의 개수를 나타냅니다.

![image](https://user-images.githubusercontent.com/22022393/128606702-09c90ed8-d669-44aa-945f-1e072da7b14b.png)

### 구현
wait 과 signal 의 개념이 등장하는데 일반적으로, wait 이 먼저 호출되어, 임계 영역에 들어갈 수 있는지 확인합니다. 혹은, 먼저 실행되어야하는 프로세스가 실행되었는지를 확인합니다. 조건에 만족하면, wait을 빠져나와 임계영역으로 들어갑니다. 이후 signal 이 호출되어, 임계 영역을 빠져나왔음을 알립니다.
```Python
S = 3 # 임계 영역에 들어갈 수 있는 쓰레드, 프로세스는 3개다.

def wait(S):
  S--
  if S < 0:
    # add this process into Waiting Queue (Sleep or Block)

def signal(S):
  S++
  if S > 0:
    # pop the process from the Waiting Queue (Wake up)

wait(S)
# critical section
signal(S)
```

##데드락(Dead Lock)

세마포어는 데드락 문제가 있는데, 아래와 같은 상황입니다.

![image](https://user-images.githubusercontent.com/22022393/128606786-4d02952b-dccf-474c-bf4c-6ca0f1455324.png)

각 프로세스의 첫째줄이 동시에 실행될 경우, 서로 wait 상태로, 다른 쪽에서 signal 을 해주기 전까지 기다리게 되는데, 둘 다 모두 계속 wait 에 머물러 있으므로, 프로그램은 절대 끝나지 않는다. 이 현상이 데드락(교착상태(Dead Lock))입니다.  
따라서, 세마포어를 쓸 때는 이와 같은 문제를 유념해두고 사용해야합니다.

## 세마포어(Semaphore)와 뮤텍스(Mutex)
<Mutex vs Semaphore>

1. Semaphore는 Mutex가 될 수 있지만 Mutex는 Semaphore가 될 수 없습니다. (Mutex 는 상태가 0, 1 두 개 뿐인 binary Semaphore)

2. Semaphore는 소유할 수 없는 반면, Mutex는 소유가 가능하며 소유주가 이에 대한 책임을 집니다. (Mutex 의 경우 상태가 두개 뿐인 lock 이므로 lock 을 ‘가질’ 수 있습니다.)

3. Mutex의 경우 Mutex를 소유하고 있는 쓰레드가 이 Mutex를 해제할 수 있습니다. 하지만 Semaphore의 경우 이러한 Semaphore를 소유하지 않는 쓰레드가 Semaphore를 해제할 수 있습니다.

4. Semaphore는 시스템 범위에 걸쳐있고 파일시스템상의 파일 형태로 존재합니다. 반면 Mutex는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 Clean up됩니다.



---
## Reference
- [운영체제 프로세스 동기화](https://thinkpro.tistory.com/124)
- [빽 투더 기본기 OS 5편. 뮤텍스와 세마포어](https://dailyheumsi.tistory.com/133)
- [joinc](https://www.joinc.co.kr/w/Site/Thread/Beginning/Mutex)
- [개발자를 꿈꾸는 프로그래머](https://jwprogramming.tistory.com/13)
